import * as i0 from '@angular/core';
import { Injectable, Optional, NgModule } from '@angular/core';
import { filter, map } from 'rxjs/operators';
import { Subject } from 'rxjs';
import * as ActionCable from 'actioncable';

class NgxActionCableConfiguration {
    constructor(key, url) {
        this.urls = new Map();
        this.urls.set(key, url);
    }
    addUrl(key, url) {
        this.urls.set(key, url);
    }
}

class NgxActionCableBroadcaster {
    constructor() {
        this._eventBus = new Subject();
    }
    broadcast(key, data) {
        this._eventBus.next({ key, data });
    }
    on(key) {
        return this._eventBus.asObservable()
            .pipe(filter(event => event.key === key), map(event => event.data));
    }
}

class NgxActionCableService {
    constructor(configuration) {
        this.configuration = configuration;
        this.cables = new Map();
        this.channels = {};
        // TODO: remove this workaround -> createWebSocketURL is undefined exception 
        // in action_cable.js
        let w = window;
        w.createWebSocketURL = ActionCable.createWebSocketURL;
        configuration.urls.forEach((url, key) => {
            let cable = this.connect(key, url);
            this.cables.set(key, cable);
        });
    }
    subscribe(key, channel, params = {}) {
        let channelName = this.getChannelName(channel, params);
        let subscriptionParams = Object.assign({ channel: channel }, params);
        let broadcaster = new NgxActionCableBroadcaster();
        let cable = this.getCabel(key);
        let subscription = cable.subscriptions.create(subscriptionParams, {
            received: (data) => {
                broadcaster.broadcast(data.action, data);
            }
        });
        this.channels[channelName] = {
            subscription: subscription,
            broadcaster: broadcaster
        };
        return broadcaster;
    }
    unsubscribe(key, channel, params = {}) {
        let channelName = this.getChannelName(channel, params);
        let cable = this.getCabel(key);
        if (!this.channels[channelName]) {
            console.info(`No Subscription for Channel ${channelName} found!`);
        }
        else {
            let subscription = this.channels[channelName].subscription;
            cable.subscriptions.remove(subscription);
        }
    }
    perform(channel, params = {}, action, data) {
        let channelName = this.getChannelName(channel, params);
        this.channels[channelName].subscription.perform(action, data);
    }
    connect(key, url) {
        let cable = ActionCable.createConsumer(url);
        cable.connect();
        return cable;
    }
    disconnect(key) {
        let cable = this.getCabel(key);
        cable.disconnect();
    }
    getChannelName(channel, params = {}) {
        let channelName = (typeof (channel) === 'object') ? channel['channel'] : channel;
        channelName += `_${JSON.stringify(params)}`; // also add params to unique channel name
        return channelName;
    }
    getCabel(key) {
        let cable = this.cables.get(key);
        if (!cable) {
            throw Error(`No cable instance for key ${key} found!`);
        }
        return cable;
    }
}
NgxActionCableService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.4", ngImport: i0, type: NgxActionCableService, deps: [{ token: NgxActionCableConfiguration, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
NgxActionCableService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.4", ngImport: i0, type: NgxActionCableService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.4", ngImport: i0, type: NgxActionCableService, decorators: [{
            type: Injectable
        }], ctorParameters: function () {
        return [{ type: NgxActionCableConfiguration, decorators: [{
                        type: Optional
                    }] }];
    } });

class NgxActionCableModule {
    static forConfig(configurationFactory) {
        return {
            ngModule: NgxActionCableModule,
            providers: [{ provide: NgxActionCableConfiguration, useFactory: configurationFactory }]
        };
    }
}
NgxActionCableModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.4", ngImport: i0, type: NgxActionCableModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgxActionCableModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.4", ngImport: i0, type: NgxActionCableModule });
NgxActionCableModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.4", ngImport: i0, type: NgxActionCableModule, providers: [
        NgxActionCableService
    ], imports: [[]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.4", ngImport: i0, type: NgxActionCableModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [],
                    providers: [
                        NgxActionCableService
                    ]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NgxActionCableBroadcaster, NgxActionCableConfiguration, NgxActionCableModule, NgxActionCableService };
//# sourceMappingURL=ngx-actioncable.mjs.map
